# LINE ‰ø°ÂæíÁÖßÁâáÊé•Êî∂Á≥ªÁµ± - ÂÆåÊï¥ÂØ¶‰ΩúÊåáÂçó

## üìã Â∞àÊ°àÊ¶ÇËø∞

Êú¨ÊåáÂçóË©≥Á¥∞Ë™™ÊòéÂ¶Ç‰ΩïÂú® MemoryArk2 ÊïôÊúÉÁÆ°ÁêÜÁ≥ªÁµ±‰∏≠Êï¥Âêà LINE Bot ÂäüËÉΩÔºåËÆì‰ø°ÂæíÂèØ‰ª•ÈÄèÈÅé LINE Áõ¥Êé•‰∏äÂÇ≥ÁÖßÁâáÂà∞Á≥ªÁµ±‰∏≠„ÄÇÊé°Áî®**ÂÆπÂô®ÂåñÂæÆÊúçÂãôÊû∂Êßã**ÔºåÁ¢∫‰øùÁ≥ªÁµ±Á©©ÂÆöÊÄßÂíåÂèØÁ∂≠Ë≠∑ÊÄß„ÄÇ

### üéØ ÂäüËÉΩÈúÄÊ±Ç
- Êé•Êî∂‰ø°ÂæíÈÄèÈÅé LINE ÂÇ≥ÈÄÅÁöÑÁÖßÁâá
- Ëá™Âãï‰∏ãËºâ‰∏¶ÂÑ≤Â≠òÂà∞ MemoryArk2 Á≥ªÁµ±
- Á∂≠Ë≠∑‰ΩøÁî®ËÄÖË≥áË®äÂíåÁÖßÁâáÈóúËÅØ
- Êèê‰æõËá™ÂãïÂõûË¶ÜÁ¢∫Ë™çÂäüËÉΩ
- ÊîØÊè¥ÊâπÈáèÁÖßÁâáËôïÁêÜ
- ÂÆåÊï¥ÁöÑÈåØË™§ËôïÁêÜÂíåÁõ£Êéß

## üèóÔ∏è Á≥ªÁµ±Êû∂Êßã

### Á∏ΩÈ´îÊû∂ÊßãÂúñ
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    HTTPS     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   LINE Âπ≥Âè∞     ‚îÇ‚îÄ‚îÄWebhook‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ        MemoryArk2 System        ‚îÇ
‚îÇ                 ‚îÇ              ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ  ‚îÇLINE Service ‚îÇ ‚îÇ   Backend   ‚îÇ‚îÇ
                                 ‚îÇ  ‚îÇ(Node.js)    ‚îÇ ‚îÇ   (Golang)  ‚îÇ‚îÇ
                                 ‚îÇ  ‚îÇPort: 3000   ‚îÇ ‚îÇ  Port: 8081 ‚îÇ‚îÇ
                                 ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
                                 ‚îÇ         ‚îÇ               ‚îÇ       ‚îÇ
                                 ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
                                 ‚îÇ                ‚ñº                ‚îÇ
                                 ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
                                 ‚îÇ    ‚îÇ  Shared Storage     ‚îÇ     ‚îÇ
                                 ‚îÇ    ‚îÇ  ‚Ä¢ SQLite DB        ‚îÇ     ‚îÇ
                                 ‚îÇ    ‚îÇ  ‚Ä¢ File Uploads     ‚îÇ     ‚îÇ
                                 ‚îÇ    ‚îÇ  ‚Ä¢ Redis Queue      ‚îÇ     ‚îÇ
                                 ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
                                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ÊäÄË°ìÊ£ßÈÅ∏Êìá
| ÁµÑ‰ª∂ | ÊäÄË°ì | ÁâàÊú¨ | Ë™™Êòé |
|------|------|------|------|
| LINE Service | Node.js + TypeScript | 20.x LTS | Webhook ËôïÁêÜËàá API Êï¥Âêà |
| Web Ê°ÜÊû∂ | Express.js | 4.x | ËºïÈáèÈ´òÊïàÁöÑ HTTP ‰º∫ÊúçÂô® |
| LINE SDK | @line/bot-sdk | 9.9.0 | ÂÆòÊñπ SDKÔºåÂäüËÉΩÂÆåÊï¥ |
| ‰ªªÂãôÈöäÂàó | Bull + Redis | 7.x | ÈùûÂêåÊ≠•ËôïÁêÜÁÖßÁâá‰∏ãËºâ |
| ÂÆπÂô®Âåñ | Docker/Podman | - | Ëàá‰∏ªÁ≥ªÁµ±Áµ±‰∏ÄÂÆπÂô®Êû∂Êßã |
| Áõ£Êéß | PM2 + Prometheus | - | Á®ãÂ∫èÁÆ°ÁêÜÂíåÁõ£Êéß |

## üìÅ Â∞àÊ°àÁµêÊßã

### LINE Service ÁõÆÈåÑÁµêÊßã
```
line-service/
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts              # ÊáâÁî®Á®ãÂºèÂÖ•Âè£
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts          # ÈÖçÁΩÆÁÆ°ÁêÜ
‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ webhook.ts        # Webhook ÊéßÂà∂Âô®
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ health.ts         # ÂÅ•Â∫∑Ê™¢Êü•
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lineService.ts    # LINE API ÊúçÂãô
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ photoService.ts   # ÁÖßÁâáËôïÁêÜÊúçÂãô
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ memoryarkApi.ts   # MemoryArk API Êï¥Âêà
‚îÇ   ‚îú‚îÄ‚îÄ queues/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ photoQueue.ts     # ÁÖßÁâáËôïÁêÜÈöäÂàó
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation.ts     # Ë´ãÊ±ÇÈ©óË≠â
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ errorHandler.ts   # ÈåØË™§ËôïÁêÜ
‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts          # TypeScript ÂûãÂà•ÂÆöÁæ©
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ logger.ts         # Êó•Ë™åÂ∑•ÂÖ∑
‚îÇ       ‚îî‚îÄ‚îÄ retry.ts          # ÈáçË©¶Ê©üÂà∂
‚îú‚îÄ‚îÄ tests/                    # Ê∏¨Ë©¶Ê™îÊ°à
‚îî‚îÄ‚îÄ docker-compose.yml        # ÈñãÁôºÁí∞Â¢ÉÂÆπÂô®ÈÖçÁΩÆ
```

## üîß Ë©≥Á¥∞ÂØ¶‰ΩúÊ≠•È©ü

### Phase 1: Áí∞Â¢ÉÊ∫ñÂÇôËàáÂü∫Á§éË®≠ÂÆö

#### 1.1 LINE ÈñãÁôºËÄÖÂ∏≥ËôüË®≠ÂÆö
```bash
# 1. ÂâçÂæÄ LINE Developers Console
# https://developers.line.biz/zh-hant/

# 2. Âª∫Á´ã Provider Âíå Channel
# 3. ÂèñÂæó‰ª•‰∏ãÊÜëË≠âÔºö
#    - Channel Access Token
#    - Channel Secret
#    - Channel ID
```

#### 1.2 Âª∫Á´ã NODE.js Â∞àÊ°à
```bash
# Âª∫Á´ãÂ∞àÊ°àÁõÆÈåÑ
mkdir line-service
cd line-service

# ÂàùÂßãÂåñ Node.js Â∞àÊ°à
npm init -y

# ÂÆâË£ùÊ†∏ÂøÉ‰æùË≥¥
npm install @line/bot-sdk express cors helmet morgan dotenv
npm install bull redis ioredis uuid axios form-data sharp
npm install winston pino

# ÂÆâË£ùÈñãÁôº‰æùË≥¥
npm install -D typescript @types/node @types/express
npm install -D @types/cors @types/morgan @types/uuid
npm install -D nodemon ts-node concurrently
npm install -D jest @types/jest supertest @types/supertest
```

#### 1.3 TypeScript ÈÖçÁΩÆ
```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

#### 1.4 Áí∞Â¢ÉËÆäÊï∏ÈÖçÁΩÆ
```bash
# .env.example
# LINE Bot Ë®≠ÂÆö
LINE_CHANNEL_ACCESS_TOKEN=your_channel_access_token
LINE_CHANNEL_SECRET=your_channel_secret
LINE_CHANNEL_ID=your_channel_id

# Redis Ë®≠ÂÆö
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_PASSWORD=

# MemoryArk API Ë®≠ÂÆö
MEMORYARK_API_URL=http://backend:8081
MEMORYARK_API_KEY=internal_service_secret_key
MEMORYARK_UPLOAD_CATEGORY_ID=1

# ÊúçÂãôË®≠ÂÆö
PORT=3000
NODE_ENV=production
LOG_LEVEL=info

# Ê™îÊ°àËôïÁêÜË®≠ÂÆö
MAX_FILE_SIZE=10485760  # 10MB
ALLOWED_MIME_TYPES=image/jpeg,image/png,image/gif,image/webp
PHOTO_DOWNLOAD_TIMEOUT=30000
MAX_CONCURRENT_DOWNLOADS=5
```

### Phase 2: Ê†∏ÂøÉÊúçÂãôÂØ¶‰Ωú

#### 2.1 ÊáâÁî®Á®ãÂºèÂÖ•Âè£ (src/index.ts)
```typescript
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import { config } from './config';
import { setupRoutes } from './routes';
import { errorHandler } from './middleware/errorHandler';
import { logger } from './utils/logger';
import { setupQueues } from './queues';

const app = express();

// ÂÆâÂÖ®‰∏≠Èñì‰ª∂
app.use(helmet());
app.use(cors({
  origin: config.NODE_ENV === 'production' ? false : true,
  credentials: true
}));

// Êó•Ë™å‰∏≠Èñì‰ª∂
app.use(morgan('combined', {
  stream: { write: (message) => logger.info(message.trim()) }
}));

// Ëß£Êûê‰∏≠Èñì‰ª∂
app.use(express.json({ limit: '2mb' }));
app.use(express.raw({ type: 'application/octet-stream', limit: '50mb' }));

// Ë∑ØÁî±Ë®≠ÂÆö
setupRoutes(app);

// ÈåØË™§ËôïÁêÜ
app.use(errorHandler);

// ÂïüÂãïÈöäÂàóÁ≥ªÁµ±
setupQueues();

const PORT = config.PORT || 3000;
app.listen(PORT, () => {
  logger.info(`LINE Service started on port ${PORT}`);
  logger.info(`Environment: ${config.NODE_ENV}`);
});

export default app;
```

#### 2.2 ÈÖçÁΩÆÁÆ°ÁêÜ (src/config/index.ts)
```typescript
import dotenv from 'dotenv';

dotenv.config();

export const config = {
  // LINE Ë®≠ÂÆö
  LINE_CHANNEL_ACCESS_TOKEN: process.env.LINE_CHANNEL_ACCESS_TOKEN!,
  LINE_CHANNEL_SECRET: process.env.LINE_CHANNEL_SECRET!,
  LINE_CHANNEL_ID: process.env.LINE_CHANNEL_ID!,
  
  // Redis Ë®≠ÂÆö
  REDIS_HOST: process.env.REDIS_HOST || 'redis',
  REDIS_PORT: parseInt(process.env.REDIS_PORT || '6379'),
  REDIS_PASSWORD: process.env.REDIS_PASSWORD,
  
  // MemoryArk API Ë®≠ÂÆö
  MEMORYARK_API_URL: process.env.MEMORYARK_API_URL || 'http://backend:8081',
  MEMORYARK_API_KEY: process.env.MEMORYARK_API_KEY!,
  MEMORYARK_UPLOAD_CATEGORY_ID: parseInt(process.env.MEMORYARK_UPLOAD_CATEGORY_ID || '1'),
  
  // ÊúçÂãôË®≠ÂÆö
  PORT: parseInt(process.env.PORT || '3000'),
  NODE_ENV: process.env.NODE_ENV || 'development',
  LOG_LEVEL: process.env.LOG_LEVEL || 'info',
  
  // Ê™îÊ°àËôïÁêÜË®≠ÂÆö
  MAX_FILE_SIZE: parseInt(process.env.MAX_FILE_SIZE || '10485760'),
  ALLOWED_MIME_TYPES: (process.env.ALLOWED_MIME_TYPES || 'image/jpeg,image/png,image/gif,image/webp').split(','),
  PHOTO_DOWNLOAD_TIMEOUT: parseInt(process.env.PHOTO_DOWNLOAD_TIMEOUT || '30000'),
  MAX_CONCURRENT_DOWNLOADS: parseInt(process.env.MAX_CONCURRENT_DOWNLOADS || '5'),
};

// È©óË≠âÂøÖË¶ÅÈÖçÁΩÆ
const requiredConfigs = [
  'LINE_CHANNEL_ACCESS_TOKEN',
  'LINE_CHANNEL_SECRET',
  'MEMORYARK_API_KEY'
];

for (const configKey of requiredConfigs) {
  if (!config[configKey as keyof typeof config]) {
    throw new Error(`Missing required configuration: ${configKey}`);
  }
}
```

#### 2.3 LINE ÊúçÂãô (src/services/lineService.ts)
```typescript
import { messagingApi, middleware, webhook } from '@line/bot-sdk';
import { v4 as uuidv4 } from 'uuid';
import { config } from '../config';
import { logger } from '../utils/logger';
import { retryWithBackoff } from '../utils/retry';

export class LineService {
  private client: messagingApi.MessagingApiClient;
  private lineConfig: { channelSecret: string };

  constructor() {
    this.client = new messagingApi.MessagingApiClient({
      channelAccessToken: config.LINE_CHANNEL_ACCESS_TOKEN
    });
    
    this.lineConfig = {
      channelSecret: config.LINE_CHANNEL_SECRET
    };
  }

  // ÂèñÂæó LINE ‰∏≠Èñì‰ª∂
  getMiddleware() {
    return middleware(this.lineConfig);
  }

  // ‰∏ãËºâÂúñÁâáÂÖßÂÆπ
  async downloadImage(messageId: string): Promise<Buffer> {
    try {
      logger.info(`ÈñãÂßã‰∏ãËºâÂúñÁâá: ${messageId}`);
      
      const stream = await this.client.getMessageContent(messageId);
      const chunks: Buffer[] = [];
      
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(`ÂúñÁâá‰∏ãËºâË∂ÖÊôÇ: ${messageId}`));
        }, config.PHOTO_DOWNLOAD_TIMEOUT);

        stream.on('data', (chunk: Buffer) => {
          chunks.push(chunk);
        });

        stream.on('end', () => {
          clearTimeout(timeout);
          const buffer = Buffer.concat(chunks);
          logger.info(`ÂúñÁâá‰∏ãËºâÂÆåÊàê: ${messageId}, Â§ßÂ∞è: ${buffer.length} bytes`);
          resolve(buffer);
        });

        stream.on('error', (error) => {
          clearTimeout(timeout);
          logger.error(`ÂúñÁâá‰∏ãËºâÂ§±Êïó: ${messageId}`, error);
          reject(error);
        });
      });
    } catch (error) {
      logger.error(`‰∏ãËºâÂúñÁâáÂ§±Êïó: ${messageId}`, error);
      throw error;
    }
  }

  // ÂèñÂæó‰ΩøÁî®ËÄÖË≥áÊñô
  async getUserProfile(userId: string): Promise<any> {
    try {
      const profile = await retryWithBackoff(
        () => this.client.getProfile(userId),
        3
      );
      return profile;
    } catch (error) {
      logger.error(`ÂèñÂæóÁî®Êà∂Ë≥áÊñôÂ§±Êïó: ${userId}`, error);
      throw error;
    }
  }

  // ÂõûË¶ÜË®äÊÅØ
  async replyMessage(replyToken: string, messages: any[]): Promise<void> {
    try {
      const retryKey = uuidv4();
      
      await retryWithBackoff(
        () => this.client.replyMessage({
          replyToken,
          messages
        }, {
          'X-Line-Retry-Key': retryKey
        }),
        3
      );
      
      logger.info(`Ë®äÊÅØÂõûË¶ÜÊàêÂäü: ${replyToken}`);
    } catch (error) {
      logger.error(`Ë®äÊÅØÂõûË¶ÜÂ§±Êïó: ${replyToken}`, error);
      throw error;
    }
  }

  // Êé®Êí≠Ë®äÊÅØ
  async pushMessage(userId: string, messages: any[]): Promise<void> {
    try {
      const retryKey = uuidv4();
      
      await retryWithBackoff(
        () => this.client.pushMessage({
          to: userId,
          messages
        }, {
          'X-Line-Retry-Key': retryKey
        }),
        3
      );
      
      logger.info(`Êé®Êí≠Ë®äÊÅØÊàêÂäü: ${userId}`);
    } catch (error) {
      logger.error(`Êé®Êí≠Ë®äÊÅØÂ§±Êïó: ${userId}`, error);
      throw error;
    }
  }

  // È©óË≠âÊ™îÊ°àÈ°ûÂûã
  validateImageMessage(event: webhook.MessageEvent): boolean {
    if (event.message.type !== 'image') {
      return false;
    }

    // ÂèØ‰ª•Âú®ÈÄôË£°Âä†ÂÖ•Êõ¥Â§öÈ©óË≠âÈÇèËºØ
    return true;
  }

  // ÁîüÊàêÁ¢∫Ë™çË®äÊÅØ
  generateConfirmationMessage(fileName: string, isSuccess: boolean): any {
    if (isSuccess) {
      return {
        type: 'text',
        text: `‚úÖ ÁÖßÁâá„Äå${fileName}„ÄçÂ∑≤ÊàêÂäü‰∏äÂÇ≥ÔºÅ\n\nÊÑüË¨ùÊÇ®ÁöÑÂàÜ‰∫´ÔºåÁÖßÁâáÂ∑≤ÂÑ≤Â≠òÂà∞ÊïôÊúÉË≥áÊñôÂ∫´‰∏≠„ÄÇ`
      };
    } else {
      return {
        type: 'text',
        text: `‚ùå ÁÖßÁâá„Äå${fileName}„Äç‰∏äÂÇ≥Â§±Êïó„ÄÇ\n\nË´ãÁ®çÂæåÂÜçË©¶ÔºåÊàñËÅØÁπ´ÁÆ°ÁêÜÂì°ÂçîÂä©„ÄÇ`
      };
    }
  }

  // ÁîüÊàêÈåØË™§Ë®äÊÅØ
  generateErrorMessage(error: string): any {
    return {
      type: 'text',
      text: `‚ùå ËôïÁêÜÂ§±ÊïóÔºö${error}\n\nË´ãÁ¢∫Ë™çÊ™îÊ°àÊ†ºÂºèÊ≠£Á¢∫ÔºåÊàñËÅØÁπ´ÁÆ°ÁêÜÂì°ÂçîÂä©„ÄÇ`
    };
  }
}

export const lineService = new LineService();
```

#### 2.4 MemoryArk API Êï¥Âêà (src/services/memoryarkApi.ts)
```typescript
import axios, { AxiosInstance, AxiosResponse } from 'axios';
import FormData from 'form-data';
import { config } from '../config';
import { logger } from '../utils/logger';

export interface UploadPhotoParams {
  file: Buffer;
  filename: string;
  mimeType: string;
  lineUserId: string;
  lineUserName: string;
  lineMessageId: string;
  virtualPath?: string;
}

export interface UploadResponse {
  success: boolean;
  data?: {
    id: number;
    name: string;
    filePath: string;
    virtualPath: string;
    size: number;
  };
  error?: {
    code: string;
    message: string;
  };
}

export class MemoryArkApiService {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: config.MEMORYARK_API_URL,
      timeout: 30000,
      headers: {
        'X-Internal-Service-Key': config.MEMORYARK_API_KEY,
        'User-Agent': 'LINE-Service/1.0.0'
      }
    });

    // Ë´ãÊ±ÇÊîîÊà™Âô®
    this.client.interceptors.request.use((config) => {
      logger.debug(`API Request: ${config.method?.toUpperCase()} ${config.url}`);
      return config;
    });

    // ÂõûÊáâÊîîÊà™Âô®
    this.client.interceptors.response.use(
      (response) => {
        logger.debug(`API Response: ${response.status} ${response.config.url}`);
        return response;
      },
      (error) => {
        logger.error(`API Error: ${error.config?.url}`, {
          status: error.response?.status,
          data: error.response?.data
        });
        return Promise.reject(error);
      }
    );
  }

  // ‰∏äÂÇ≥ÁÖßÁâáÂà∞ MemoryArk
  async uploadPhoto(params: UploadPhotoParams): Promise<UploadResponse> {
    try {
      const formData = new FormData();
      
      // Âü∫Êú¨Ê™îÊ°àË≥áË®ä
      formData.append('file', params.file, {
        filename: params.filename,
        contentType: params.mimeType
      });
      
      // MemoryArk Ê™îÊ°àÊ¨Ñ‰Ωç
      formData.append('originalName', params.filename);
      formData.append('virtualPath', params.virtualPath || `/LINE‰∏äÂÇ≥/${new Date().getFullYear()}/${params.filename}`);
      formData.append('categoryId', config.MEMORYARK_UPLOAD_CATEGORY_ID.toString());
      
      // LINE ÁâπÂÆöÊ¨Ñ‰ΩçÔºàÈúÄË¶ÅÊì¥Â±ï File Ê®°ÂûãÔºâ
      formData.append('lineUserId', params.lineUserId);
      formData.append('lineUserName', params.lineUserName);
      formData.append('lineMessageId', params.lineMessageId);
      
      // Ê™îÊ°àÊèèËø∞
      formData.append('description', `Áî± LINE Áî®Êà∂ ${params.lineUserName} ‰∏äÂÇ≥`);
      formData.append('contentType', 'photo');
      formData.append('tags', 'LINE,ÁÖßÁâá,‰ø°ÂæíÂàÜ‰∫´');

      const response: AxiosResponse<UploadResponse> = await this.client.post(
        '/api/internal/line/upload-photo',
        formData,
        {
          headers: {
            ...formData.getHeaders(),
            'Content-Length': formData.getLengthSync().toString()
          }
        }
      );

      return response.data;
    } catch (error: any) {
      logger.error('‰∏äÂÇ≥ÁÖßÁâáÂà∞ MemoryArk Â§±Êïó', error);
      
      if (error.response) {
        return {
          success: false,
          error: {
            code: error.response.status.toString(),
            message: error.response.data?.message || '‰∏äÂÇ≥Â§±Êïó'
          }
        };
      }
      
      return {
        success: false,
        error: {
          code: 'NETWORK_ERROR',
          message: 'Á∂≤Ë∑ØÈÄ£Á∑öÂ§±Êïó'
        }
      };
    }
  }

  // ÂèñÂæóÂàÜÈ°ûÂàóË°®
  async getCategories(): Promise<any[]> {
    try {
      const response = await this.client.get('/api/categories');
      return response.data.data || [];
    } catch (error) {
      logger.error('ÂèñÂæóÂàÜÈ°ûÂàóË°®Â§±Êïó', error);
      return [];
    }
  }

  // ÂÅ•Â∫∑Ê™¢Êü•
  async healthCheck(): Promise<boolean> {
    try {
      const response = await this.client.get('/api/health');
      return response.status === 200;
    } catch (error) {
      logger.error('MemoryArk ÂÅ•Â∫∑Ê™¢Êü•Â§±Êïó', error);
      return false;
    }
  }
}

export const memoryarkApi = new MemoryArkApiService();
```

#### 2.5 ÁÖßÁâáËôïÁêÜÈöäÂàó (src/queues/photoQueue.ts)
```typescript
import Bull from 'bull';
import { config } from '../config';
import { lineService } from '../services/lineService';
import { memoryarkApi } from '../services/memoryarkApi';
import { logger } from '../utils/logger';

export interface PhotoJobData {
  messageId: string;
  userId: string;
  replyToken: string;
  timestamp: number;
}

// Âª∫Á´ã Redis ÈÄ£Êé•
const redisConfig = {
  host: config.REDIS_HOST,
  port: config.REDIS_PORT,
  password: config.REDIS_PASSWORD,
  maxRetriesPerRequest: 3,
  retryDelayOnFailover: 100
};

// Âª∫Á´ãÁÖßÁâáËôïÁêÜÈöäÂàó
export const photoQueue = new Bull('photo-processing', {
  redis: redisConfig,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000
    },
    removeOnComplete: 100,
    removeOnFail: 50
  }
});

// ÁÖßÁâáËôïÁêÜÂ∑•‰ΩúËôïÁêÜÂô®
photoQueue.process('download-and-upload', config.MAX_CONCURRENT_DOWNLOADS, async (job) => {
  const { messageId, userId, replyToken, timestamp } = job.data as PhotoJobData;
  
  logger.info(`ÈñãÂßãËôïÁêÜÁÖßÁâá‰ªªÂãô: ${messageId}`);
  
  try {
    // Ê≠•È©ü 1: ‰∏ãËºâÁÖßÁâá
    job.progress(10);
    const imageBuffer = await lineService.downloadImage(messageId);
    
    // Ê≠•È©ü 2: ÂèñÂæó‰ΩøÁî®ËÄÖË≥áÊñô
    job.progress(30);
    const userProfile = await lineService.getUserProfile(userId);
    
    // Ê≠•È©ü 3: È©óË≠âÊ™îÊ°à
    job.progress(40);
    if (imageBuffer.length > config.MAX_FILE_SIZE) {
      throw new Error(`Ê™îÊ°àÈÅéÂ§ß: ${imageBuffer.length} bytes`);
    }
    
    // Ê≠•È©ü 4: Âà§Êñ∑Ê™îÊ°àÈ°ûÂûã
    job.progress(50);
    const mimeType = detectMimeType(imageBuffer);
    if (!config.ALLOWED_MIME_TYPES.includes(mimeType)) {
      throw new Error(`‰∏çÊîØÊè¥ÁöÑÊ™îÊ°àÈ°ûÂûã: ${mimeType}`);
    }
    
    // Ê≠•È©ü 5: ‰∏äÂÇ≥Âà∞ MemoryArk
    job.progress(70);
    const fileName = `${userProfile.displayName}_${Date.now()}.jpg`;
    const uploadResult = await memoryarkApi.uploadPhoto({
      file: imageBuffer,
      filename: fileName,
      mimeType,
      lineUserId: userId,
      lineUserName: userProfile.displayName,
      lineMessageId: messageId
    });
    
    // Ê≠•È©ü 6: ÁôºÈÄÅÁ¢∫Ë™çË®äÊÅØ
    job.progress(90);
    if (uploadResult.success) {
      const confirmMessage = lineService.generateConfirmationMessage(fileName, true);
      await lineService.replyMessage(replyToken, [confirmMessage]);
      logger.info(`ÁÖßÁâáËôïÁêÜÊàêÂäü: ${messageId}`);
    } else {
      throw new Error(uploadResult.error?.message || '‰∏äÂÇ≥Â§±Êïó');
    }
    
    job.progress(100);
    return { success: true, fileName };
    
  } catch (error: any) {
    logger.error(`ÁÖßÁâáËôïÁêÜÂ§±Êïó: ${messageId}`, error);
    
    // ÁôºÈÄÅÈåØË™§Ë®äÊÅØ
    try {
      const errorMessage = lineService.generateErrorMessage(error.message);
      await lineService.replyMessage(replyToken, [errorMessage]);
    } catch (replyError) {
      logger.error(`ÂõûË¶ÜÈåØË™§Ë®äÊÅØÂ§±Êïó: ${messageId}`, replyError);
    }
    
    throw error;
  }
});

// Á∞°ÂñÆÁöÑ MIME È°ûÂûãÊ™¢Ê∏¨
function detectMimeType(buffer: Buffer): string {
  const header = buffer.toString('hex', 0, 4).toUpperCase();
  
  if (header.startsWith('FFD8FF')) return 'image/jpeg';
  if (header.startsWith('89504E47')) return 'image/png';
  if (header.startsWith('47494638')) return 'image/gif';
  if (header.startsWith('52494646')) return 'image/webp';
  
  return 'application/octet-stream';
}

// ÈöäÂàó‰∫ã‰ª∂Áõ£ËÅΩ
photoQueue.on('completed', (job, result) => {
  logger.info(`ÁÖßÁâáËôïÁêÜ‰ªªÂãôÂÆåÊàê: ${job.id}`, result);
});

photoQueue.on('failed', (job, err) => {
  logger.error(`ÁÖßÁâáËôïÁêÜ‰ªªÂãôÂ§±Êïó: ${job?.id}`, err);
});

photoQueue.on('stalled', (job) => {
  logger.warn(`ÁÖßÁâáËôïÁêÜ‰ªªÂãôÂç°‰Ωè: ${job.id}`);
});

export const setupQueues = () => {
  logger.info('ÁÖßÁâáËôïÁêÜÈöäÂàóÂ∑≤ÂïüÂãï');
};
```

#### 2.6 Webhook ÊéßÂà∂Âô® (src/controllers/webhook.ts)
```typescript
import { Request, Response } from 'express';
import { webhook } from '@line/bot-sdk';
import { lineService } from '../services/lineService';
import { photoQueue } from '../queues/photoQueue';
import { logger } from '../utils/logger';

export class WebhookController {
  // ËôïÁêÜ LINE Webhook ‰∫ã‰ª∂
  async handleWebhook(req: Request, res: Response): Promise<void> {
    try {
      // LINE SDK Â∑≤Á∂ìÈÄèÈÅé‰∏≠Èñì‰ª∂È©óË≠â‰∫ÜÁ∞ΩÁ´†
      const events: webhook.Event[] = req.body.events;
      
      // Á´ãÂç≥ÂõûÊáâ LINE Âπ≥Âè∞
      res.status(200).send('OK');
      
      // ËôïÁêÜÊØèÂÄã‰∫ã‰ª∂
      for (const event of events) {
        await this.processEvent(event);
      }
      
    } catch (error) {
      logger.error('Webhook ËôïÁêÜÂ§±Êïó', error);
      res.status(500).send('Internal Server Error');
    }
  }

  // ËôïÁêÜÂñÆÂÄã‰∫ã‰ª∂
  private async processEvent(event: webhook.Event): Promise<void> {
    try {
      switch (event.type) {
        case 'message':
          await this.handleMessageEvent(event);
          break;
        case 'follow':
          await this.handleFollowEvent(event);
          break;
        case 'unfollow':
          await this.handleUnfollowEvent(event);
          break;
        default:
          logger.debug(`Êú™ËôïÁêÜÁöÑ‰∫ã‰ª∂È°ûÂûã: ${event.type}`);
      }
    } catch (error) {
      logger.error(`‰∫ã‰ª∂ËôïÁêÜÂ§±Êïó: ${event.type}`, error);
    }
  }

  // ËôïÁêÜË®äÊÅØ‰∫ã‰ª∂
  private async handleMessageEvent(event: webhook.MessageEvent): Promise<void> {
    const { message, source, replyToken, timestamp } = event;
    
    if (source.type !== 'user') {
      logger.debug('ÂøΩÁï•ÈùûÁî®Êà∂Ë®äÊÅØ');
      return;
    }

    switch (message.type) {
      case 'image':
        await this.handleImageMessage(event);
        break;
      case 'text':
        await this.handleTextMessage(event);
        break;
      default:
        logger.debug(`Êú™ËôïÁêÜÁöÑË®äÊÅØÈ°ûÂûã: ${message.type}`);
    }
  }

  // ËôïÁêÜÂúñÁâáË®äÊÅØ
  private async handleImageMessage(event: webhook.MessageEvent): Promise<void> {
    const { message, source, replyToken, timestamp } = event;
    
    if (message.type !== 'image' || source.type !== 'user') {
      return;
    }

    const userId = source.userId;
    const messageId = message.id;

    logger.info(`Êî∂Âà∞ÂúñÁâáË®äÊÅØ: ${messageId} from ${userId}`);

    try {
      // È©óË≠âÂúñÁâáË®äÊÅØ
      if (!lineService.validateImageMessage(event)) {
        const errorMessage = lineService.generateErrorMessage('‰∏çÊîØÊè¥ÁöÑÂúñÁâáÊ†ºÂºè');
        await lineService.replyMessage(replyToken, [errorMessage]);
        return;
      }

      // Âä†ÂÖ•ËôïÁêÜÈöäÂàó
      await photoQueue.add('download-and-upload', {
        messageId,
        userId,
        replyToken,
        timestamp
      }, {
        priority: 10,
        delay: 1000, // Á®çÂæÆÂª∂ÈÅ≤ËôïÁêÜÔºåÈÅøÂÖçÈÅéÊñºÈ†ªÁπÅ
        jobId: `photo-${messageId}` // Èò≤Ê≠¢ÈáçË§áËôïÁêÜ
      });

      logger.info(`ÂúñÁâáËôïÁêÜ‰ªªÂãôÂ∑≤Âä†ÂÖ•ÈöäÂàó: ${messageId}`);

    } catch (error) {
      logger.error(`ËôïÁêÜÂúñÁâáË®äÊÅØÂ§±Êïó: ${messageId}`, error);
      
      try {
        const errorMessage = lineService.generateErrorMessage('Á≥ªÁµ±ÂøôÁ¢å‰∏≠ÔºåË´ãÁ®çÂæåÂÜçË©¶');
        await lineService.replyMessage(replyToken, [errorMessage]);
      } catch (replyError) {
        logger.error(`ÂõûË¶ÜÈåØË™§Ë®äÊÅØÂ§±Êïó: ${messageId}`, replyError);
      }
    }
  }

  // ËôïÁêÜÊñáÂ≠óË®äÊÅØ
  private async handleTextMessage(event: webhook.MessageEvent): Promise<void> {
    const { message, source, replyToken } = event;
    
    if (message.type !== 'text' || source.type !== 'user') {
      return;
    }

    const text = message.text.toLowerCase().trim();
    const userId = source.userId;

    logger.info(`Êî∂Âà∞ÊñáÂ≠óË®äÊÅØ: "${text}" from ${userId}`);

    try {
      let replyMessage: any;

      switch (text) {
        case 'help':
        case 'Âπ´Âä©':
        case 'Ë™™Êòé':
          replyMessage = {
            type: 'text',
            text: `üì∏ Ê≠°Ëøé‰ΩøÁî®ÊïôÊúÉÁÖßÁâá‰∏äÂÇ≥ÊúçÂãôÔºÅ

üîπ Áõ¥Êé•ÂÇ≥ÈÄÅÁÖßÁâáÂç≥ÂèØËá™Âãï‰∏äÂÇ≥
üîπ ÊîØÊè¥ JPG„ÄÅPNG„ÄÅGIF„ÄÅWebP Ê†ºÂºè
üîπ ÂñÆÂºµÁÖßÁâáÊúÄÂ§ß 10MB
üîπ ‰∏äÂÇ≥ÂæåÊúÉËá™ÂãïÂõûË¶ÜÁ¢∫Ë™çË®äÊÅØ

Â¶ÇÊúâÂïèÈ°åË´ãËÅØÁπ´ÁÆ°ÁêÜÂì°„ÄÇ`
          };
          break;

        case 'status':
        case 'ÁãÄÊÖã':
          const queueStats = await photoQueue.getWaiting();
          replyMessage = {
            type: 'text',
            text: `üìä Á≥ªÁµ±ÁãÄÊÖãÔºö
üî∏ Á≠âÂæÖËôïÁêÜÁÖßÁâáÔºö${queueStats.length} Âºµ
üî∏ ÊúçÂãôÁãÄÊÖãÔºöÊ≠£Â∏∏ÈÅãË°å`
          };
          break;

        default:
          replyMessage = {
            type: 'text',
            text: 'üì∏ Ë´ãÁõ¥Êé•ÂÇ≥ÈÄÅÁÖßÁâáÔºåÁ≥ªÁµ±ÊúÉËá™ÂãïÁÇ∫ÊÇ®‰∏äÂÇ≥ÔºÅ\n\nËº∏ÂÖ•„ÄåÂπ´Âä©„ÄçÊü•Áúã‰ΩøÁî®Ë™™Êòé„ÄÇ'
          };
      }

      await lineService.replyMessage(replyToken, [replyMessage]);

    } catch (error) {
      logger.error(`ËôïÁêÜÊñáÂ≠óË®äÊÅØÂ§±Êïó: ${userId}`, error);
    }
  }

  // ËôïÁêÜÈóúÊ≥®‰∫ã‰ª∂
  private async handleFollowEvent(event: webhook.FollowEvent): Promise<void> {
    const { source, replyToken } = event;
    
    if (source.type !== 'user') return;

    const userId = source.userId;
    logger.info(`Êñ∞Áî®Êà∂ÈóúÊ≥®: ${userId}`);

    try {
      const welcomeMessage = {
        type: 'text',
        text: `üéâ Ê≠°ËøéÂä†ÂÖ•ÊïôÊúÉÁÖßÁâáÂàÜ‰∫´ÊúçÂãôÔºÅ

üì∏ ‰ΩøÁî®ÊñπÂºèÔºö
‚Ä¢ Áõ¥Êé•ÂÇ≥ÈÄÅÁÖßÁâáÂç≥ÂèØËá™Âãï‰∏äÂÇ≥
‚Ä¢ ÁÖßÁâáÊúÉÂÑ≤Â≠òÂà∞ÊïôÊúÉË≥áÊñôÂ∫´
‚Ä¢ ÊîØÊè¥Â§öÁ®ÆÊ†ºÂºèÔºåÊúÄÂ§ß 10MB

Ëº∏ÂÖ•„ÄåÂπ´Âä©„ÄçÁç≤ÂèñÊõ¥Â§öË≥áË®ä„ÄÇ

È°òÁ•ûÁ•ùÁ¶èÊÇ®ÔºÅ üôè`
      };

      await lineService.replyMessage(replyToken, [welcomeMessage]);
    } catch (error) {
      logger.error(`ÁôºÈÄÅÊ≠°ËøéË®äÊÅØÂ§±Êïó: ${userId}`, error);
    }
  }

  // ËôïÁêÜÂèñÊ∂àÈóúÊ≥®‰∫ã‰ª∂
  private async handleUnfollowEvent(event: webhook.UnfollowEvent): Promise<void> {
    const { source } = event;
    
    if (source.type !== 'user') return;

    const userId = source.userId;
    logger.info(`Áî®Êà∂ÂèñÊ∂àÈóúÊ≥®: ${userId}`);
    
    // ÂèØ‰ª•Âú®ÈÄôË£°Ë®òÈåÑÁµ±Ë®àË≥áË®äÊàñÊ∏ÖÁêÜÁõ∏ÈóúË≥áÊñô
  }
}

export const webhookController = new WebhookController();
```

### Phase 3: Docker ÂÆπÂô®ÂåñÈÖçÁΩÆ

#### 3.1 Dockerfile
```dockerfile
# Multi-stage build for production
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Copy source code
COPY . .

# Build TypeScript
RUN npm run build

# Production stage
FROM node:20-alpine AS production

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S lineservice -u 1001

WORKDIR /app

# Copy built application
COPY --from=builder --chown=lineservice:nodejs /app/dist ./dist
COPY --from=builder --chown=lineservice:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=lineservice:nodejs /app/package*.json ./

# Create uploads directory
RUN mkdir -p /app/uploads && chown lineservice:nodejs /app/uploads

# Switch to non-root user
USER lineservice

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node dist/healthcheck.js

EXPOSE 3000

CMD ["node", "dist/index.js"]
```

#### 3.2 Docker Compose Êï¥Âêà
```yaml
# Êõ¥Êñ∞‰∏ªÂ∞àÊ°àÁöÑ docker-compose.yml
version: '3.8'

services:
  # ÂéüÊúâÊúçÂãô...
  backend:
    # ... ÂéüÊúâÈÖçÁΩÆ

  frontend:
    # ... ÂéüÊúâÈÖçÁΩÆ

  nginx:
    # ... ÂéüÊúâÈÖçÁΩÆ
    # ÈúÄË¶ÅÊñ∞Â¢û LINE webhook Ë∑ØÁî±

  # Êñ∞Â¢ûÊúçÂãô
  redis:
    image: redis:7.0.11-alpine
    container_name: memoryark-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    networks:
      - memoryark-network

  line-service:
    build: 
      context: ./line-service
      dockerfile: Dockerfile
    container_name: memoryark-line-service
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - LINE_CHANNEL_ACCESS_TOKEN=${LINE_CHANNEL_ACCESS_TOKEN}
      - LINE_CHANNEL_SECRET=${LINE_CHANNEL_SECRET}
      - LINE_CHANNEL_ID=${LINE_CHANNEL_ID}
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - MEMORYARK_API_URL=http://backend:8081
      - MEMORYARK_API_KEY=${MEMORYARK_API_KEY}
      - MEMORYARK_UPLOAD_CATEGORY_ID=${MEMORYARK_UPLOAD_CATEGORY_ID}
    volumes:
      - ./uploads:/app/uploads
      - ./logs:/app/logs
    depends_on:
      - redis
      - backend
    networks:
      - memoryark-network

volumes:
  redis_data:
  # ... ÂéüÊúâ volumes

networks:
  memoryark-network:
    driver: bridge
```

#### 3.3 Nginx ÈÖçÁΩÆÊõ¥Êñ∞
```nginx
# nginx/conf.d/default.conf Êõ¥Êñ∞
server {
    listen 80;
    server_name localhost;

    # ÂéüÊúâÈÖçÁΩÆ...

    # LINE Webhook Á´ØÈªû
    location /api/line/webhook {
        proxy_pass http://line-service:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # LINE Webhook ÁâπÊÆäË®≠ÂÆö
        proxy_read_timeout 30s;
        proxy_connect_timeout 10s;
        proxy_send_timeout 30s;
        
        # ‰øùÊåÅ LINE Á∞ΩÁ´†È©óË≠âÈúÄË¶ÅÁöÑÂéüÂßã body
        proxy_buffering off;
        client_max_body_size 2m;
    }

    # LINE ÊúçÂãôÂÅ•Â∫∑Ê™¢Êü•
    location /api/line/health {
        proxy_pass http://line-service:3000/health;
        proxy_set_header Host $host;
    }

    # ÂÖ∂‰ªñÂéüÊúâË∑ØÁî±...
}
```

### Phase 4: MemoryArk ÂæåÁ´ØÊì¥Â±ï

#### 4.1 Êñ∞Â¢û LINE Â∞àÁî® API Á´ØÈªû
```go
// backend/internal/api/handlers/line_handler.go
package handlers

import (
    "net/http"
    "strconv"
    "time"
    
    "github.com/gin-gonic/gin"
    "gorm.io/gorm"
    
    "memoryark/internal/models"
    "memoryark/internal/services"
)

type LineHandler struct {
    fileService *services.FileService
    db          *gorm.DB
}

func NewLineHandler(fileService *services.FileService, db *gorm.DB) *LineHandler {
    return &LineHandler{
        fileService: fileService,
        db:          db,
    }
}

// ÂÖßÈÉ®ÊúçÂãô‰∏≠Èñì‰ª∂
func (h *LineHandler) InternalServiceMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        apiKey := c.GetHeader("X-Internal-Service-Key")
        expectedKey := os.Getenv("MEMORYARK_API_KEY")
        
        if apiKey == "" || apiKey != expectedKey {
            c.JSON(http.StatusUnauthorized, gin.H{
                "success": false,
                "error": gin.H{
                    "code":    "UNAUTHORIZED",
                    "message": "Invalid internal service key",
                },
            })
            c.Abort()
            return
        }
        
        // Ë®≠ÁΩÆÂÖßÈÉ®ÊúçÂãôÊ®ôË≠ò
        c.Set("internal_service", "line")
        c.Next()
    }
}

// LINE ÁÖßÁâá‰∏äÂÇ≥ËôïÁêÜ
func (h *LineHandler) UploadPhoto(c *gin.Context) {
    // Ëß£ÊûêË°®ÂñÆË≥áÊñô
    form, err := c.MultipartForm()
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code":    "INVALID_FORM",
                "message": "Invalid multipart form",
            },
        })
        return
    }

    files := form.File["file"]
    if len(files) == 0 {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code":    "NO_FILE",
                "message": "No file uploaded",
            },
        })
        return
    }

    file := files[0]
    
    // ÂèñÂæó LINE ÁâπÂÆöÂèÉÊï∏
    lineUserId := c.PostForm("lineUserId")
    lineUserName := c.PostForm("lineUserName")
    lineMessageId := c.PostForm("lineMessageId")
    
    if lineUserId == "" || lineUserName == "" || lineMessageId == "" {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code":    "MISSING_LINE_INFO",
                "message": "Missing LINE user information",
            },
        })
        return
    }

    // Âª∫Á´ãÊàñÂèñÂæó LINE Áî®Êà∂
    lineUser, err := h.getOrCreateLineUser(lineUserId, lineUserName)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code":    "USER_ERROR",
                "message": "Failed to process LINE user",
            },
        })
        return
    }

    // Ê∫ñÂÇôÊ™îÊ°à‰∏äÂÇ≥ÂèÉÊï∏
    uploadParams := services.FileUploadParams{
        File:         file,
        UploadedBy:   lineUser.ID,
        OriginalName: c.PostForm("originalName"),
        VirtualPath:  c.PostForm("virtualPath"),
        CategoryID:   parseUintParam(c.PostForm("categoryId")),
        Description:  c.PostForm("description"),
        Tags:         c.PostForm("tags"),
        ContentType:  c.PostForm("contentType"),
        
        // LINE ÁâπÂÆöÊ¨Ñ‰Ωç
        LineUserId:   lineUserId,
        LineMessageId: lineMessageId,
    }

    // ‰∏äÂÇ≥Ê™îÊ°à
    uploadedFile, err := h.fileService.UploadFile(uploadParams)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code":    "UPLOAD_FAILED",
                "message": err.Error(),
            },
        })
        return
    }

    // Ë®òÈåÑÊ¥ªÂãïÊó•Ë™å
    h.logActivity(lineUser.ID, "upload", "file", &uploadedFile.ID, 
        fmt.Sprintf("Via LINE: %s", lineMessageId))

    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "id":          uploadedFile.ID,
            "name":        uploadedFile.Name,
            "filePath":    uploadedFile.FilePath,
            "virtualPath": uploadedFile.VirtualPath,
            "size":        uploadedFile.FileSize,
        },
    })
}

// ÂèñÂæóÊàñÂª∫Á´ã LINE Áî®Êà∂
func (h *LineHandler) getOrCreateLineUser(lineUserId, lineUserName string) (*models.User, error) {
    var user models.User
    
    // ÂÖàÊü•ÊâæÊòØÂê¶Â∑≤Â≠òÂú®Ôºà‰ΩøÁî® email ‰ΩúÁÇ∫ÂîØ‰∏ÄË≠òÂà•Ôºâ
    lineEmail := fmt.Sprintf("line_%s@line.local", lineUserId)
    
    err := h.db.Where("email = ?", lineEmail).First(&user).Error
    if err == nil {
        // Êõ¥Êñ∞Áî®Êà∂ÂêçÁ®±ÔºàÂ¶ÇÊûúÊúâËÆäÊõ¥Ôºâ
        if user.Name != lineUserName {
            user.Name = lineUserName
            user.LastLoginAt = &time.Time{}
            *user.LastLoginAt = time.Now()
            h.db.Save(&user)
        }
        return &user, nil
    }
    
    if err != gorm.ErrRecordNotFound {
        return nil, err
    }
    
    // Âª∫Á´ãÊñ∞Áî®Êà∂
    now := time.Now()
    user = models.User{
        Email:       lineEmail,
        Name:        lineUserName,
        Role:        "user",
        Status:      "approved", // LINE Áî®Êà∂Ëá™ÂãïÂØ©Ê†∏ÈÄöÈÅé
        LastLoginAt: &now,
        CreatedAt:   now,
        UpdatedAt:   now,
    }
    
    if err := h.db.Create(&user).Error; err != nil {
        return nil, err
    }
    
    return &user, nil
}

// Ë®òÈåÑÊ¥ªÂãïÊó•Ë™å
func (h *LineHandler) logActivity(userID uint, action, resourceType string, resourceID *uint, details string) {
    log := models.ActivityLog{
        UserID:       userID,
        Action:       action,
        ResourceType: resourceType,
        ResourceID:   resourceID,
        Details:      details,
        CreatedAt:    time.Now(),
    }
    h.db.Create(&log)
}

// ËºîÂä©ÂáΩÊï∏
func parseUintParam(param string) *uint {
    if param == "" {
        return nil
    }
    val, err := strconv.ParseUint(param, 10, 32)
    if err != nil {
        return nil
    }
    result := uint(val)
    return &result
}
```

#### 4.2 Ë∑ØÁî±Ë®ªÂÜä
```go
// backend/internal/api/router.go Êõ¥Êñ∞
func SetupRouter(cfg *config.Config, db *gorm.DB) *gin.Engine {
    // ... ÂéüÊúâ‰ª£Á¢º

    // LINE ÊúçÂãôÂ∞àÁî®Ë∑ØÁî±
    lineHandler := handlers.NewLineHandler(fileService, db)
    internal := api.Group("/internal")
    internal.Use(lineHandler.InternalServiceMiddleware())
    {
        line := internal.Group("/line")
        {
            line.POST("/upload-photo", lineHandler.UploadPhoto)
            line.GET("/categories", lineHandler.GetCategories)
            line.GET("/health", lineHandler.HealthCheck)
        }
    }

    return r
}
```

#### 4.3 Êì¥Â±ï File Ê®°Âûã
```go
// backend/internal/models/models.go Êõ¥Êñ∞ File ÁµêÊßã
type File struct {
    // ... ÂéüÊúâÊ¨Ñ‰Ωç
    
    // Êñ∞Â¢û LINE Áõ∏ÈóúÊ¨Ñ‰Ωç
    LineUserId    string `json:"lineUserId,omitempty" gorm:"size:100;index"`
    LineMessageId string `json:"lineMessageId,omitempty" gorm:"size:100;index"`
    
    // ... ÂÖ∂‰ªñÂéüÊúâÊ¨Ñ‰Ωç
}
```

### Phase 5: ÈÉ®ÁΩ≤ËàáÁõ£Êéß

#### 5.1 ÁîüÁî¢Áí∞Â¢ÉÈÉ®ÁΩ≤ËÖ≥Êú¨
```bash
#!/bin/bash
# deploy.sh

set -e

echo "üöÄ ÈñãÂßãÈÉ®ÁΩ≤ LINE ÁÖßÁâáÊúçÂãô..."

# Ê™¢Êü•Áí∞Â¢ÉËÆäÊï∏
if [ -z "$LINE_CHANNEL_ACCESS_TOKEN" ]; then
    echo "‚ùå Áº∫Â∞ë LINE_CHANNEL_ACCESS_TOKEN"
    exit 1
fi

if [ -z "$LINE_CHANNEL_SECRET" ]; then
    echo "‚ùå Áº∫Â∞ë LINE_CHANNEL_SECRET"
    exit 1
fi

# ÂÇô‰ªΩÁèæÊúâË≥áÊñô
echo "üì¶ ÂÇô‰ªΩÁèæÊúâË≥áÊñô..."
sudo cp -r ./data ./data.backup.$(date +%Y%m%d_%H%M%S)

# ÊãâÂèñÊúÄÊñ∞‰ª£Á¢º
echo "üì• ÊãâÂèñÊúÄÊñ∞‰ª£Á¢º..."
git pull origin main

# Âª∫Êßã LINE ÊúçÂãô
echo "üî® Âª∫Êßã LINE ÊúçÂãô..."
cd line-service
npm ci --production
npm run build
cd ..

# ÂÅúÊ≠¢ÁèæÊúâÂÆπÂô®
echo "‚èπÔ∏è ÂÅúÊ≠¢ÁèæÊúâÂÆπÂô®..."
podman-compose down

# ÂïüÂãïÊõ¥Êñ∞ÂæåÁöÑÊúçÂãô
echo "‚ñ∂Ô∏è ÂïüÂãïÊúçÂãô..."
podman-compose up -d

# Á≠âÂæÖÊúçÂãôÂïüÂãï
echo "‚è≥ Á≠âÂæÖÊúçÂãôÂïüÂãï..."
sleep 30

# ÂÅ•Â∫∑Ê™¢Êü•
echo "üè• Âü∑Ë°åÂÅ•Â∫∑Ê™¢Êü•..."
if curl -f http://localhost:7001/api/line/health; then
    echo "‚úÖ LINE ÊúçÂãôÈÅãË°åÊ≠£Â∏∏"
else
    echo "‚ùå LINE ÊúçÂãôÂÅ•Â∫∑Ê™¢Êü•Â§±Êïó"
    podman-compose logs line-service
    exit 1
fi

if curl -f http://localhost:7001/api/health; then
    echo "‚úÖ ‰∏ªÊúçÂãôÈÅãË°åÊ≠£Â∏∏"
else
    echo "‚ùå ‰∏ªÊúçÂãôÂÅ•Â∫∑Ê™¢Êü•Â§±Êïó"
    exit 1
fi

echo "üéâ ÈÉ®ÁΩ≤ÂÆåÊàêÔºÅ"
echo "üìä ÂèØ‰ª•Êü•ÁúãÊó•Ë™åÔºö"
echo "  podman-compose logs -f line-service"
echo "  podman-compose logs -f backend"
```

#### 5.2 Áõ£ÊéßÂíåÊó•Ë™åÈÖçÁΩÆ
```yaml
# monitoring/docker-compose.monitoring.yml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:latest
    container_name: memoryark-prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
    networks:
      - memoryark-network

  grafana:
    image: grafana/grafana:latest
    container_name: memoryark-grafana
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards
    networks:
      - memoryark-network

volumes:
  prometheus_data:
  grafana_data:

networks:
  memoryark-network:
    external: true
```

#### 5.3 Prometheus ÈÖçÁΩÆ
```yaml
# monitoring/prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'line-service'
    static_configs:
      - targets: ['line-service:3000']
    metrics_path: '/metrics'
    
  - job_name: 'memoryark-backend'
    static_configs:
      - targets: ['backend:8081']
    metrics_path: '/metrics'
    
  - job_name: 'redis'
    static_configs:
      - targets: ['redis:6379']
```

### Phase 6: Ê∏¨Ë©¶ËàáÈ©óË≠â

#### 6.1 ÂñÆÂÖÉÊ∏¨Ë©¶
```typescript
// tests/services/lineService.test.ts
import { LineService } from '../../src/services/lineService';
import { config } from '../../src/config';

describe('LineService', () => {
  let lineService: LineService;

  beforeEach(() => {
    lineService = new LineService();
  });

  describe('validateImageMessage', () => {
    it('should validate image message correctly', () => {
      const mockEvent = {
        type: 'message',
        message: {
          type: 'image',
          id: 'test-message-id'
        }
      };

      const result = lineService.validateImageMessage(mockEvent as any);
      expect(result).toBe(true);
    });

    it('should reject non-image message', () => {
      const mockEvent = {
        type: 'message',
        message: {
          type: 'text',
          text: 'hello'
        }
      };

      const result = lineService.validateImageMessage(mockEvent as any);
      expect(result).toBe(false);
    });
  });

  describe('generateConfirmationMessage', () => {
    it('should generate success message', () => {
      const message = lineService.generateConfirmationMessage('test.jpg', true);
      
      expect(message.type).toBe('text');
      expect(message.text).toContain('ÊàêÂäü‰∏äÂÇ≥');
      expect(message.text).toContain('test.jpg');
    });

    it('should generate failure message', () => {
      const message = lineService.generateConfirmationMessage('test.jpg', false);
      
      expect(message.type).toBe('text');
      expect(message.text).toContain('‰∏äÂÇ≥Â§±Êïó');
      expect(message.text).toContain('test.jpg');
    });
  });
});
```

#### 6.2 Êï¥ÂêàÊ∏¨Ë©¶
```typescript
// tests/integration/webhook.test.ts
import request from 'supertest';
import app from '../../src/index';
import { photoQueue } from '../../src/queues/photoQueue';

describe('Webhook Integration', () => {
  afterEach(async () => {
    await photoQueue.clean(0, 'completed');
    await photoQueue.clean(0, 'failed');
  });

  it('should handle image message webhook', async () => {
    const webhookPayload = {
      events: [{
        type: 'message',
        message: {
          type: 'image',
          id: 'test-message-id'
        },
        source: {
          type: 'user',
          userId: 'test-user-id'
        },
        replyToken: 'test-reply-token',
        timestamp: Date.now()
      }]
    };

    const response = await request(app)
      .post('/webhook')
      .send(webhookPayload)
      .expect(200);

    // È©óË≠â‰ªªÂãôÂ∑≤Âä†ÂÖ•ÈöäÂàó
    const waiting = await photoQueue.getWaiting();
    expect(waiting.length).toBe(1);
  });
});
```

#### 6.3 Ë≤†ËºâÊ∏¨Ë©¶
```bash
#!/bin/bash
# load-test.sh

echo "üß™ Âü∑Ë°åË≤†ËºâÊ∏¨Ë©¶..."

# ÂÆâË£ù artillery
npm install -g artillery

# Âª∫Á´ãÊ∏¨Ë©¶ËÖ≥Êú¨
cat > load-test.yml << EOF
config:
  target: 'http://localhost:7001'
  phases:
    - duration: 60
      arrivalRate: 5
  
scenarios:
  - name: "Health Check"
    requests:
      - get:
          url: "/api/line/health"
          
  - name: "Webhook Simulation"
    requests:
      - post:
          url: "/api/line/webhook"
          headers:
            X-Line-Signature: "test-signature"
          json:
            events: []
EOF

# Âü∑Ë°åÊ∏¨Ë©¶
artillery run load-test.yml

echo "‚úÖ Ë≤†ËºâÊ∏¨Ë©¶ÂÆåÊàê"
```

## üìä Â∞àÊ°àÁÆ°ÁêÜËàáÊôÇÁ®ãË¶èÂäÉ

### ÈñãÁôºÊôÇÁ®ãË°®
| ÈöéÊÆµ | ‰ªªÂãô | È†ê‰º∞ÊôÇÈñì | Ë≤†Ë≤¨‰∫∫ |
|------|------|---------|--------|
| Week 1 | Áí∞Â¢ÉÂª∫ÁΩÆËàáÂü∫Á§éÈÖçÁΩÆ | 3-4 Â§© | ÂæåÁ´ØÈñãÁôºËÄÖ |
| Week 2 | LINE Service Ê†∏ÂøÉÈñãÁôº | 5-6 Â§© | ÂÖ®Á´ØÈñãÁôºËÄÖ |
| Week 3 | MemoryArk Êï¥ÂêàËàáÊ∏¨Ë©¶ | 4-5 Â§© | ÂæåÁ´ØÈñãÁôºËÄÖ |
| Week 4 | ÈÉ®ÁΩ≤ÈÖçÁΩÆËàáÂÑ™Âåñ | 3-4 Â§© | DevOps |
| Week 5 | Ê∏¨Ë©¶ËàáÊñáÊ™î | 2-3 Â§© | QA + ÊäÄË°ìÊñáÊ™î |

### ÈáåÁ®ãÁ¢ëÊ™¢Êü•Èªû
- ‚úÖ **M1**: LINE Webhook Âü∫Êú¨Êé•Êî∂ (Week 1 ÁµêÊùü)
- ‚úÖ **M2**: ÁÖßÁâá‰∏ãËºâËàáËôïÁêÜ (Week 2 ÁµêÊùü)  
- ‚úÖ **M3**: MemoryArk ‰∏äÂÇ≥Êï¥Âêà (Week 3 ÁµêÊùü)
- ‚úÖ **M4**: ÁîüÁî¢Áí∞Â¢ÉÈÉ®ÁΩ≤ (Week 4 ÁµêÊùü)
- ‚úÖ **M5**: ‰ΩøÁî®ËÄÖÈ©óÊî∂Ê∏¨Ë©¶ (Week 5 ÁµêÊùü)

## üõ°Ô∏è ÂÆâÂÖ®ÊÄßËÄÉÈáè

### Ë≥áÊñô‰øùË≠∑
- LINE ‰ΩøÁî®ËÄÖË≥áÊñôÊúÄÂ∞èÂåñÊî∂ÈõÜ
- ÁÖßÁâáÂÇ≥Ëº∏ÈÅéÁ®ãÂä†ÂØÜ
- ÊïèÊÑüÈÖçÁΩÆ‰ΩøÁî®Áí∞Â¢ÉËÆäÊï∏
- ÂÆöÊúüÊ∏ÖÁêÜÊö´Â≠òÊ™îÊ°à

### Â≠òÂèñÊéßÂà∂
- ÂÖßÈÉ® API ‰ΩøÁî®Â∞àÁî®Ë™çË≠âÈáëÈë∞
- LINE Webhook Á∞ΩÁ´†È©óË≠â
- ÂÆπÂô®Á∂≤Ë∑ØÈöîÈõ¢
- Èùû root Áî®Êà∂ÈÅãË°åÂÆπÂô®

### Áõ£ÊéßËàáÂØ©Ë®à
- ÂÆåÊï¥ÁöÑÊìç‰ΩúÊó•Ë™åË®òÈåÑ
- Áï∞Â∏∏Ë°åÁÇ∫Áõ£ÊéßÂëäË≠¶
- ÂÆöÊúüÂÆâÂÖ®ÊÄßÊ™¢Êü•
- Ë≥áÊñôÂÇô‰ªΩËàáÁÅΩÈõ£Âæ©Âéü

## üìà ÊïàËÉΩÂÑ™ÂåñÂª∫Ë≠∞

### Á≥ªÁµ±ÊïàËÉΩ
- Redis ‰ªªÂãôÈöäÂàóÈÅøÂÖçÈòªÂ°û
- ‰∏¶ÁôºËôïÁêÜÊï∏ÈáèÊéßÂà∂
- ÂúñÁâáÂ£ìÁ∏ÆÊ∏õÂ∞ëÂÑ≤Â≠òÁ©∫Èñì
- CDN Âä†ÈÄüÈùúÊÖãË≥áÊ∫ê

### ÊàêÊú¨ÊéßÂà∂
- LINE API ÂëºÂè´Ê¨°Êï∏Áõ£Êéß
- Ê™îÊ°àÂÑ≤Â≠òÁ©∫ÈñìÂÑ™Âåñ
- ÂÆπÂô®Ë≥áÊ∫ê‰ΩøÁî®Áõ£Êéß
- Ëá™ÂãïÂåñÈÅãÁ∂≠Ê∏õÂ∞ë‰∫∫ÂäõÊàêÊú¨

## üöÄ Êú™‰æÜÊì¥Â±ïË¶èÂäÉ

### ÂäüËÉΩÊì¥Â±ï
- ÊîØÊè¥ÂΩ±ÁâáÊ™îÊ°à‰∏äÂÇ≥
- ÊâπÈáèÁÖßÁâáÊâìÂåÖ‰∏ãËºâ
- ÁÖßÁâáËá™ÂãïÂàÜÈ°ûÊ®ôÁ±§
- Â§öË™ûË®ÄÊîØÊè¥

### ÊäÄË°ìÊì¥Â±ï
- ÊîØÊè¥ÂÖ∂‰ªñÂç≥ÊôÇÈÄöË®äÂπ≥Âè∞
- Ê©üÂô®Â≠∏ÁøíÂΩ±ÂÉèË≠òÂà•
- Èõ≤Á´ØÂÑ≤Â≠òÊï¥Âêà
- ÂæÆÊúçÂãôÊû∂ÊßãÂÑ™Âåñ

## üìù Á∏ΩÁµê

Êú¨ÂØ¶‰ΩúÊåáÂçóÊèê‰æõ‰∫ÜÂÆåÊï¥ÁöÑ LINE ÁÖßÁâáÊé•Êî∂ÂäüËÉΩÊï¥ÂêàÊñπÊ°àÔºåÂåÖÂê´Ôºö

1. **Ë©≥Á¥∞ÁöÑÊäÄË°ìÂØ¶‰Ωú** - ÂæûÁí∞Â¢ÉÊ∫ñÂÇôÂà∞Á®ãÂºèÁ¢ºÂØ¶Áèæ
2. **ÂÆåÊï¥ÁöÑÊû∂ÊßãË®≠Ë®à** - ÂÆπÂô®ÂåñÂæÆÊúçÂãôÊû∂Êßã
3. **ÁîüÁî¢Â∞±Á∑íÈÖçÁΩÆ** - Docker„ÄÅÁõ£Êéß„ÄÅÊó•Ë™å„ÄÅÂÆâÂÖ®ÊÄß
4. **Ê∏¨Ë©¶ËàáÈÉ®ÁΩ≤** - ÂñÆÂÖÉÊ∏¨Ë©¶„ÄÅÊï¥ÂêàÊ∏¨Ë©¶„ÄÅË≤†ËºâÊ∏¨Ë©¶
5. **ÈÅãÁ∂≠ËàáÁõ£Êéß** - ÂÅ•Â∫∑Ê™¢Êü•„ÄÅÊïàËÉΩÁõ£Êéß„ÄÅÈåØË™§ËôïÁêÜ

ÈÄèÈÅéÈÄôÂÄãÁ≥ªÁµ±ÔºåÊïôÊúÉ‰ø°ÂæíÂèØ‰ª•Êñπ‰æøÂú∞ÈÄèÈÅé LINE ÂàÜ‰∫´ÁÖßÁâáÔºåÁ≥ªÁµ±ÊúÉËá™ÂãïËôïÁêÜ‰∏¶Êï¥ÂêàÂà∞ MemoryArk2 ÁÆ°ÁêÜÂπ≥Âè∞‰∏≠ÔºåÊèêÂçáÊï∏‰ΩçË≥áÁî¢ÁÆ°ÁêÜÊïàÁéá„ÄÇ

Â∞àÊ°àÊé°Áî®Áèæ‰ª£ÂåñÁöÑÊäÄË°ìÊ£ßÂíåÊúÄ‰Ω≥ÂØ¶Ë∏êÔºåÁ¢∫‰øùÁ≥ªÁµ±ÁöÑÁ©©ÂÆöÊÄß„ÄÅÂÆâÂÖ®ÊÄßÂíåÂèØÁ∂≠Ë≠∑ÊÄßÔºåÁÇ∫ÊïôÊúÉÊï∏‰ΩçÂåñËΩâÂûãÊèê‰æõÂº∑ÊúâÂäõÁöÑÊäÄË°ìÊîØÊè¥„ÄÇ